name: Validate Dependencies

on:
  pull_request:
    paths:
      - '.meta/dependencies.json'
      - 'package.json'
      - 'requirements.txt'
      - 'Cargo.toml'
      - 'pyproject.toml'
  workflow_dispatch:

jobs:
  validate:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.12'

      - name: Fetch Central Registry
        run: |
          curl -sf https://raw.githubusercontent.com/organvm-iv-taxis/orchestration-start-here/main/registry-v2.json \
            -o registry-v2.json || {
            echo "::warning::Could not fetch central registry; falling back to local"
            if [ -f registry-v2.json ]; then
              echo "Using local registry-v2.json"
            else
              echo "::error::No registry available"
              exit 1
            fi
          }

      - name: Fetch Governance Rules
        run: |
          curl -sf https://raw.githubusercontent.com/organvm-iv-taxis/orchestration-start-here/main/governance-rules.json \
            -o governance-rules.json || {
            echo "::warning::Could not fetch governance rules; falling back to local"
            if [ -f governance-rules.json ]; then
              echo "Using local governance-rules.json"
            else
              echo "::error::No governance rules available"
              exit 1
            fi
          }

      - name: Validate Dependency Rules
        id: validate
        run: |
          python3 - <<'PYEOF'
          import json
          import sys
          from collections import defaultdict

          CURRENT_REPO = "${{ github.repository }}"

          # Load registry
          with open("registry-v2.json") as f:
              registry = json.load(f)
          with open("governance-rules.json") as f:
              governance = json.load(f)

          # Build repo map
          repo_map = {}
          for organ_key, organ_data in registry.get("organs", {}).items():
              for repo in organ_data.get("repositories", []):
                  key = f"{repo['org']}/{repo['name']}"
                  repo["_organ_key"] = organ_key
                  repo_map[key] = repo

          # Organ ordering
          organ_levels = {
              "organvm-i-theoria": 1,
              "organvm-ii-poiesis": 2,
              "organvm-iii-ergon": 3,
              "organvm-iv-taxis": 4,
              "organvm-v-logos": 5,
              "organvm-vi-koinonia": 6,
              "organvm-vii-kerygma": 7,
              "meta-organvm": 8,
          }
          restricted = {1, 2, 3}

          violations = []
          warnings = []

          # Get current repo data
          current = repo_map.get(CURRENT_REPO)
          if not current:
              print(f"::warning::Repo {CURRENT_REPO} not found in registry")
              sys.exit(0)

          current_org = CURRENT_REPO.split("/")[0]
          current_level = organ_levels.get(current_org, 0)

          # Check dependencies for this repo
          for dep in current.get("dependencies", []):
              # Target exists?
              if dep not in repo_map:
                  warnings.append(f"Dependency target not in registry: {dep}")
                  continue

              # Self-dependency?
              if dep == CURRENT_REPO:
                  violations.append(f"Self-dependency: {CURRENT_REPO}")
                  continue

              # Back-edge check
              dep_org = dep.split("/")[0]
              dep_level = organ_levels.get(dep_org, 0)

              if current_level in restricted and dep_level in restricted:
                  if current_level < dep_level:
                      violations.append(
                          f"Back-edge: {CURRENT_REPO} (organ level {current_level}) "
                          f"depends on {dep} (organ level {dep_level})"
                      )

          # Also validate .meta/dependencies.json if it exists
          try:
              with open(".meta/dependencies.json") as f:
                  meta_deps = json.load(f)
              for dep_entry in meta_deps.get("dependencies", {}).get("internal", {}).get("depends_on", []):
                  dep_key = f"{dep_entry.get('org', '')}/{dep_entry.get('repo', '')}"
                  if dep_key not in repo_map:
                      warnings.append(f".meta/dependencies.json target not in registry: {dep_key}")
          except FileNotFoundError:
              pass

          # Build full graph for cycle detection on changed deps
          adj = defaultdict(list)
          for key, repo in repo_map.items():
              for dep in repo.get("dependencies", []):
                  adj[key].append(dep)

          WHITE, GRAY, BLACK = 0, 1, 2
          color = defaultdict(lambda: WHITE)
          cycles = []

          def dfs(node, path):
              color[node] = GRAY
              path.append(node)
              for neighbor in adj[node]:
                  if color[neighbor] == GRAY:
                      idx = path.index(neighbor)
                      cycles.append(path[idx:] + [neighbor])
                  elif color[neighbor] == WHITE:
                      dfs(neighbor, path)
              path.pop()
              color[node] = BLACK

          # Only check from current repo's connected component
          if color[CURRENT_REPO] == WHITE:
              dfs(CURRENT_REPO, [])

          if cycles:
              for cycle in cycles:
                  violations.append(f"Circular dependency: {' -> '.join(cycle)}")

          # Check transitive depth
          max_depth = governance.get("dependency_rules", {}).get("max_transitive_depth", 4)

          def measure_depth(node, visited=None):
              if visited is None:
                  visited = set()
              if node in visited:
                  return 0
              visited.add(node)
              if not adj[node]:
                  return 0
              return 1 + max(measure_depth(n, visited) for n in adj[node])

          depth = measure_depth(CURRENT_REPO)
          if depth > max_depth:
              violations.append(f"Transitive depth {depth} exceeds limit {max_depth}")

          # Write results
          results = []
          if violations:
              results.append("## Dependency Validation: FAILED\n")
              for v in violations:
                  results.append(f"- {v}\n")
          else:
              results.append("## Dependency Validation: PASSED\n")
              results.append(f"- Repo: {CURRENT_REPO}\n")
              results.append(f"- Dependencies: {len(current.get('dependencies', []))}\n")
              results.append(f"- Transitive depth: {depth}\n")

          if warnings:
              results.append("\n### Warnings\n")
              for w in warnings:
                  results.append(f"- {w}\n")

          with open("validation-results.txt", "w") as f:
              f.write("".join(results))

          if violations:
              for v in violations:
                  print(f"::error::{v}")
              print(f"FAILED: {len(violations)} violation(s)")
              sys.exit(1)
          else:
              print(f"PASSED: All dependency rules satisfied for {CURRENT_REPO}")
              sys.exit(0)
          PYEOF

      - name: Comment Results on PR
        if: always() && github.event_name == 'pull_request'
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            let results = 'No validation results generated.';
            try {
              results = fs.readFileSync('validation-results.txt', 'utf8');
            } catch (e) {
              results = 'Validation script did not produce results.';
            }
            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: `${results}\n\n---\n*Automated by ORGAN-IV dependency validation*`
            });
